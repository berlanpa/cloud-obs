<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>AI-OBS Camera</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #preview {
      flex: 1;
      width: 100%;
      object-fit: cover;
      background: #1a1a1a;
    }
    #controls {
      padding: 20px;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    #status {
      font-size: 14px;
      color: #888;
      text-align: center;
    }
    .status-connecting { color: #ffa500; }
    .status-connected { color: #00ff00; }
    .status-error { color: #ff0000; }
    #cameraId {
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      color: #fff;
    }
    button {
      padding: 15px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }
    #connectBtn {
      background: #00ff00;
      color: #000;
    }
    #disconnectBtn {
      background: #ff0000;
      color: #fff;
      display: none;
    }
    #flipBtn {
      background: #333;
      color: #fff;
      display: none;
    }
    .connected #connectBtn { display: none; }
    .connected #disconnectBtn { display: block; }
    .connected #flipBtn { display: block; }
    select {
      padding: 15px;
      font-size: 16px;
      border: 2px solid #333;
      border-radius: 8px;
      background: #1a1a1a;
      color: #fff;
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="container">
    <video id="preview" autoplay playsinline muted></video>
    <div id="controls">
      <div id="cameraId"></div>
      <div id="status" class="status-connecting">Initializing...</div>
      <select id="cameraSelect">
        <option value="">Select Camera...</option>
      </select>
      <button id="connectBtn">Start Broadcasting</button>
      <button id="flipBtn">Flip Camera</button>
      <button id="disconnectBtn">Stop Broadcasting</button>
    </div>
  </div>

  <script src="https://unpkg.com/livekit-client@1.15.13/dist/livekit-client.umd.min.js"></script>
  <script>
    // Configuration
    const urlParams = new URLSearchParams(window.location.search);
    const cameraId = urlParams.get('id') || 'cam-' + Math.floor(Math.random() * 5 + 1);
    const apiUrl = window.location.origin;
    const roomName = 'main';

    // DOM elements
    const preview = document.getElementById('preview');
    const status = document.getElementById('status');
    const cameraIdEl = document.getElementById('cameraId');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const flipBtn = document.getElementById('flipBtn');
    const cameraSelect = document.getElementById('cameraSelect');
    const container = document.getElementById('container');

    // State
    let room = null;
    let localVideoTrack = null;
    let localAudioTrack = null;
    let currentFacingMode = 'environment';  // 'environment' = back camera, 'user' = front camera
    let availableCameras = [];

    // Update UI
    cameraIdEl.textContent = cameraId.toUpperCase();

    function updateStatus(message, statusClass) {
      status.textContent = message;
      status.className = statusClass;
    }

    // Enumerate available cameras
    async function enumerateCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        availableCameras = devices.filter(device => device.kind === 'videoinput');

        // Populate camera select dropdown
        cameraSelect.innerHTML = '<option value="">Auto-select camera</option>';
        availableCameras.forEach((device, index) => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.textContent = device.label || `Camera ${index + 1}`;
          cameraSelect.appendChild(option);
        });

        console.log(`Found ${availableCameras.length} cameras`);
      } catch (err) {
        console.error('Error enumerating cameras:', err);
      }
    }

    // Flip between front and back camera
    async function flipCamera() {
      if (!room || !room.localParticipant) return;

      updateStatus('Flipping camera...', 'status-connecting');

      // Toggle facing mode
      currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';

      try {
        // Disable current camera
        await room.localParticipant.setCameraEnabled(false);

        // Enable with new facing mode
        await room.localParticipant.setCameraEnabled(true, {
          facingMode: currentFacingMode
        });

        // Re-attach to preview
        const videoPublication = Array.from(room.localParticipant.videoTracks.values())[0];
        if (videoPublication && videoPublication.track) {
          localVideoTrack = videoPublication.track;
          localVideoTrack.attach(preview);
        }

        updateStatus(`Streaming as ${cameraId} (${currentFacingMode === 'user' ? 'Front' : 'Back'})`, 'status-connected');
      } catch (error) {
        console.error('Error flipping camera:', error);
        updateStatus('Failed to flip camera', 'status-error');
      }
    }

    async function getToken() {
      updateStatus('Getting access token...', 'status-connecting');

      const response = await fetch(`${apiUrl}/token`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          identity: cameraId,
          room: roomName,
          role: 'camera'
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${await response.text()}`);
      }

      const data = await response.json();
      if (!data.success) {
        throw new Error(data.error || 'Failed to get token');
      }

      return data.data;
    }

    async function connectCamera() {
      try {
        // Get token
        const { token, url } = await getToken();
        updateStatus('Connecting to LiveKit...', 'status-connecting');

        // Create room
        room = new LivekitClient.Room({
          adaptiveStream: true,
          dynacast: true,
          videoCaptureDefaults: {
            resolution: LivekitClient.VideoPresets.h720.resolution,
            facingMode: 'environment' // Back camera by default
          }
        });

        // Setup event handlers
        room.on(LivekitClient.RoomEvent.Connected, () => {
          updateStatus(`Connected as ${cameraId}`, 'status-connected');
          container.classList.add('connected');
        });

        room.on(LivekitClient.RoomEvent.Disconnected, () => {
          updateStatus('Disconnected', 'status-error');
          container.classList.remove('connected');
        });

        room.on(LivekitClient.RoomEvent.Reconnecting, () => {
          updateStatus('Reconnecting...', 'status-connecting');
        });

        room.on(LivekitClient.RoomEvent.Reconnected, () => {
          updateStatus(`Connected as ${cameraId}`, 'status-connected');
        });

        // Connect to room
        await room.connect(url, token);

        // Enable camera
        updateStatus('Starting camera...', 'status-connecting');
        await room.localParticipant.setCameraEnabled(true);

        // Enable microphone
        await room.localParticipant.setMicrophoneEnabled(true);

        // Get local video track and attach to preview
        const videoPublication = Array.from(room.localParticipant.videoTracks.values())[0];
        if (videoPublication && videoPublication.track) {
          localVideoTrack = videoPublication.track;
          localVideoTrack.attach(preview);
        }

        updateStatus(`Streaming as ${cameraId}`, 'status-connected');

      } catch (error) {
        console.error('Connection error:', error);
        updateStatus(`Error: ${error.message}`, 'status-error');
      }
    }

    async function disconnectCamera() {
      if (room) {
        await room.disconnect();
        room = null;
      }
      if (localVideoTrack) {
        localVideoTrack.detach();
        localVideoTrack = null;
      }
      updateStatus('Disconnected', 'status-error');
      container.classList.remove('connected');
    }

    // Button handlers
    connectBtn.addEventListener('click', connectCamera);
    disconnectBtn.addEventListener('click', disconnectCamera);
    flipBtn.addEventListener('click', flipCamera);

    // Enumerate cameras on page load
    enumerateCameras();

    // Prevent screen sleep
    if ('wakeLock' in navigator) {
      let wakeLock = null;
      const requestWakeLock = async () => {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
        } catch (err) {
          console.warn('Wake lock error:', err);
        }
      };
      document.addEventListener('visibilitychange', () => {
        if (wakeLock !== null && document.visibilityState === 'visible') {
          requestWakeLock();
        }
      });
      requestWakeLock();
    }

    // Auto-connect on page load
    updateStatus('Ready - Tap to start', 'status-connecting');
  </script>
</body>
</html>
